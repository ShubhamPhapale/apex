// Stress test: Complex mutation patterns
// Expected: 109
fn modify(mut x: i32, add_val: i32) -> i32 {
    x = x + add_val;
    x = x * 2;
    return x;
}

fn main() -> i32 {
    // Basic mutation
    let mut a: i32 = 10;
    a = a + 5;  // 15
    a = a * 2;  // 30
    
    // Mutation in loops
    let mut sum: i32 = 0;
    for i in 0..5 {
        sum = sum + i;  // 0 + 1 + 2 + 3 + 4 = 10
    }
    
    // Mutation in nested loops
    let mut product: i32 = 1;
    for i in 1..4 {
        for j in 1..3 {
            product = product + i * j;  // (1*1 + 1*2) + (2*1 + 2*2) + (3*1 + 3*2) = 3 + 6 + 9 = 18
        }
    }
    
    // Mutation in conditionals
    let mut val: i32 = 100;
    if val > 50 {
        val = val - 30;  // 70
    } else {
        val = val + 30;
    }
    
    // Mutation through function
    let mut b: i32 = 5;
    b = modify(b, 10);  // (5 + 10) * 2 = 30
    
    // Mutation in while loop
    let mut count: i32 = 0;
    let mut temp: i32 = 20;
    while temp > 0 {
        count = count + 1;
        temp = temp - 5;  // Runs 4 times
    }
    
    // Mutation in blocks
    let mut block_val: i32 = {
        let mut x: i32 = 3;
        x = x + 2;  // 5
        x = x * 2;  // 10
        x
    };
    block_val = block_val + 6;  // 16
    
    // a=30, sum=10, product=19 (1+2+2+4+3+6+1=19), b=30, count=4, block_val=16, val=70
    // Actually: product = 1 initially
    // Loop i=1: j=1: 1+1*1=2, j=2: 2+1*2=4
    // Loop i=2: j=1: 4+2*1=6, j=2: 6+2*2=10
    // Loop i=3: j=1: 10+3*1=13, j=2: 13+3*2=19
    return a + sum + product + b + count + block_val;  // 30 + 10 + 19 + 30 + 4 + 16 = 109
}
