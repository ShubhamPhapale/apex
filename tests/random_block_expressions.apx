// Random test: Block expressions with various return patterns
// Expected: 251
fn compute_block(x: i32) -> i32 {
    let result: i32 = {
        let temp1: i32 = x * 2;
        let temp2: i32 = temp1 + 10;
        let temp3: i32 = {
            let inner: i32 = temp2 / 2;
            inner + 5
        };
        temp3 * 3
    };
    return result;
}

fn main() -> i32 {
    // Simple block
    let a: i32 = {
        let x: i32 = 10;
        let y: i32 = 20;
        x + y
    };  // 30
    
    // Block with conditionals
    let b: i32 = {
        let val: i32 = 15;
        if val > 10 {
            val * 2
        } else {
            val + 10
        }
    };  // 30
    
    // Block with loops
    let c: i32 = {
        let mut sum: i32 = 0;
        for i in 0..5 {
            sum = sum + i;
        }
        sum * 2
    };  // 20
    
    // Nested blocks
    let d: i32 = {
        let outer: i32 = {
            let inner: i32 = {
                5 + 10
            };
            inner * 2
        };
        outer + 10
    };  // 40
    
    // Block with match
    let e: i32 = {
        let val: i32 = 3;
        match val {
            0 => 10,
            1 => 20,
            2 => 30,
            3 => 40,
            _ => 50,
        }
    };  // 40
    
    // Function with block
    let f: i32 = compute_block(10);  // ((10*2)+10)/2+5)*3 = (20+10)/2+5)*3 = (15+5)*3 = 60
    
    // Block in loop
    let mut g: i32 = 0;
    for i in 0..3 {
        let block_val: i32 = {
            let temp: i32 = i * 2;
            temp + 3
        };
        g = g + block_val;  // (0*2+3) + (1*2+3) + (2*2+3) = 3+5+7 = 15
    }
    
    let total: i32 = a + b + c + d + e + f + g;  // 30+30+20+40+40+60+15 = 235
    
    return total + 16;  // 251
}
